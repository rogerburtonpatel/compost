Names and email addresses:
val name_email_map : (string * string) list =
[("Roger Burtonpatel", "roger.burtonpatel@tufts.edu");
 ("Randy Dang", "randy.dang@tufts.edu");
 ("Jasper Geer", "jasper.geer@tufts.edu");
 ("Jackson Warhover", "jackson.warhover@tufts.edu")]  

----------------------------------------------------------------------------------------
How to run scripts:

To compile the compiler, type the following command:
    dune build 
Or, alternatively, you can type:
    make

To run all tests in our test suite, type the following command:
    ./run_tests.bash 

To run a specific test in our test suite, the usage is defined as follows:
    ./run_tests.bash -{a|p|u|t|m|c|r} test_name.com 
where the inputted flag specifies which phase to test:
    -a: test scanning and parsing
    -p: test all phases specified in -a *and* preprocessing 
    -u: test all phases specified in -p *and* disambiguation of globals and locals
    -t: test all phases specified in -u *and* type checking 
    -m: test all phases specified in -t *and* explicit memory management 
    -c: test all phases of compilation and diff the LLVM output against a gold standard 
    -r: test all phases of compilation, *run the program*, and diff the program's output 
        against a gold standard.
and `test_name.com` is the name of a Compost program that can be found 
in some subdirectory within tests/ dependent on the inputted flag: 
    -a: looks in tests/ast/
    -p: looks in tests/past/
    -u: looks in tests/uast/
    -t: looks in tests/tast/
    -m: looks in tests/mast/
    -c: looks in tests/llvm/
    -r: looks in tests/run/
For example, to run our simple "Hello World" test, run: 
`./run_tests.bash -r hello-world.com`

To run *just* the compiler on a source file (producing the executable), run:
    ./gcc file.com
where `file.com` is the file containing a Compost program (the full path 
needs to be specified if not in the current working directory). A runnable 
executable called `file` would then be created in the location where 
`file.com` was.
(gcc stands for "good compost compiler", and this is not to be confused 
with the C compiler of the same name)

To compile *and* run a source file with one command, run:
    ./gci file.com
where `file.com` is the name of a file containing the Compost program to 
compile and run. Note that this approach does *not* guarantee memory 
safety because gci utilizes lli, which leaks memory. 

To print the LLVM IR produced by our compiler, run:
    dune exec compost file.com
where `file.com` is the name of the file containing a Compost program. 

------------------------------------------------------------------------
Programs in our integration testing suite:

Currently, in our integration testing suite, we have the following test 
files (all of which work with this version of our compiler). Such files 
can be found in subdirectories of the tests/ subdirectory, and the 
expected output of running each test can be found in the `.out` file with 
the same name. Such expected output can be the expected output of the 
compiled program, the expected output of a pretty-printer at an intermediate 
compilation stage, or the expected error message to be thrown in the case of 
a negative test. If a `.out` file is *not* found in that subdirectory, then 
the expected output is the same as the Compost program.

See the "run" tests for mostly positive tests and the type checker tests
for mostly negative tests.

SCANNER / PARSER TESTS (found in tests/ast/):

`annotation.com`: tests scanning/parsing of function type annotations 

`arrow.com`: tests scanning/parsing of names containing arrows (e.g. `->a`)

`begin.com`: tests scanning/parsing of begin statement

`case.com`: tests scanning/parsing of basic pattern match

`comments1.com`: tests scanning/parsing of code containing comments at end of 
                 lines, each of which may or may not be separated from the code 
                 with whitespace

`comments2.com`: tests scanning/parsing of code with a comment containing a 
                 closing parentheses, ensuring the comment parentheses is ignored

`comments3.com`: tests that code containing an open parenthesis matched by a 
                 closing parenthesis in a comment (and thus ignored) does *not* parse

`comments4.com`: tests that semicolons in symbols *do* parse correctly, as they do not 
                 indicate a comment when inside a string

`datatype.com`: tests scanning/parsing of a simple list datatype definition 

`define.com`: tests scanning/parsing of a simple function definition 

`defineArgs.com`: tests scanning/parsing of a function definition with multiple arguments 

`defineErr.com`: tests that function definition without a body does *not* parse

`emoji.com`: tests scanning/parsing of code with an emoji variable name 

`exprlist.com`: tests scanning/parsing of code applying many arguments to a function 

`funCall.com`: tests scanning/parsing of code that applies multiple functions, some of 
               which in a higher-order manner

`hello.com`: simple test for scanning/parsing of a symbol literal

`ifnest.com`: tests scanning/parsing of nested if statements 

`illegal.com`: tests that illegal symbol literals (symbols containing a backslash followed 
               by a character that is not a quotation or another backslash) do *not* parse 

`let.com`: tests scanning/parsing of let statement 

`lit.com`: tests scanning/parsing of multiple types of literals 

`litfbool.com`: tests that attempting to use a pre-determined boolean keyword (`false`) for 
                a variable name does *not* parse

`litfintlit.com`: tests that attempting to use an integer literal for a variable name does 
                  *not* parse

`litfintlit2.com`: tests that attempting to use a negative integer literal for a variable 
                   name does *not* parse

`litfsym.com`: tests that attempting to use a symbol literal for a variable name does 
               *not* parse

`litfunit.com`: tests that attempting to use the unit literal for a variable name does 
                *not* parse

`lrm1.com` through `lrm10.com`: tests successful scanning/parsing of a variety of functionality 
                                described in the LRM (mainly to ensure that examples given in 
                                the LRM were syntactically correct)

`nameint.com`: tests successful scanning/parsing of a program that uses "int" as a variable name

`semi0.com`: tests scanning/parsing of code containing a semicolon inside a symbol

`semi1.com`: tests scanning/parsing of code containing a semicolon inside a symbol that is passed 
             in as a function argument

`semi2.com`: tests that code with a semicolon inside a symbol that tries to treat the rest of the 
             line as a comment does *not* parse, verifying that semicolons inside symbols are not 
             treated as comments 

`semi25.com`: tests scanner/parser success for code where multi-line symbols are passed in as 
              function arguments 

`simple.com`: tests scanning/parsing of a simple val definition 

`underscore.com`: tests that code attempting to use the underscore character (reserved for wildcard 
                  pattern matching) does *not* parse

`unicode.com`: tests scanning/parsing of code containing a variable name composed of Japanese characters 

`unit.com`: tests scanning/parsing of code invoking the unit literal 

`weirdspace.com` through `weirdspace4.com`: tests successful scanning/parsing of code containing an assortment of 
                                            whitespace characters (e.g. carriage returns, spaces, newlines, and 
                                            tabs) within and outside symbol literals

PREPROCESSOR TESTS (found in tests/past/):

`badval.com`: tests preprocessing of nonsensical val definitions. This *should* successfully pass the preprocessing 
              stage, as the error will be caught by our semantic checker.

`begin.com`: tests preprocessing of begin statement 

`caseval.com`: tests preprocessing of case statement referencing a name bound by a val macro

`define.com`: tests preprocessing of simple function definition 

`definetwo.com`: tests preprocessing of two different function definitions 

`definetwob.com`: tests that code containing a duplicate function definition does *not* pass the preprocessor stage 

`depth.com`: tests that code attempting to include its own source file does *not* pass the preprocessor stage 

`double.com`: tests code that includes multiple other source files

`dtdupe.com`: tests that code using the same name for a val-bound macro and a datatype variant-constructor does *not*
              pass the preprocessing stage

`globdef.com`: tests preprocessing of global definition 

`globlet.com`: tests preprocessing of global definition used in let statements

`nest.com`: tests preprocessing of code that includes one other source file which itself includes a different source file 

`prim.com`: tests that code attempting to bind a name that is already bound to some primitive operation does *not*
            pass the preprocessing stage

`test.com`: tests preprocessing of two different function definitions. A source file that is included in some 
            other preprocessing tests.

`use.com`: tests preprocessing of code that uses one other source file

`val.com`: tests preprocessing of a single `val` definition that is not used anywhere else in the code

`valdef1.com`: tests preprocessing of val definitions (treating them as macros)

`weirdval.com`: tests preprocessing of val definitions in more versatile cases 

DISAMBIGUATOR TESTS (found in tests/uast/):

`hello-world.com`: tests disambiguation of a simple Hello World program (treating the function name as 
                   a global variable)

`rename.com`: tests disambiguation of program that re-binds the same variable name within a let expression

TYPE CHECKER TESTS (found in tests/tast/tast-fail OR tests/tast/test-succ):

`applyLiteralError.com`: tests that a semantic error is thrown when attempting to apply a literal 
                         as a function

`applyNonFuncError.com`: tests that a semantic error is thrown when attempting to apply a name that 
                         is not a function

`datatypes.com`: tests that a custom datatypes stress test passes the type checking phase *without* errors

`dupUnboundError.com`: tests that a semantic error is thrown when attempting to call `dup` on an unbound 
                       name 

`dupVconNameSameTypeError.com`: tests that a semantic error is thrown when attempting to use the same 
                                variant constructor name twice

`duplicateVConError.com`: tests that a semantic error is thrown when defining two variant constructors 
                          (of different datatypes) with the same name 

`emptyCaseError.com`: tests that a semantic error is thrown when there exists a `case` expression with 
                      no branches

`funArgNumMismatchTypeError.com`: tests that a semantic error is thrown when a function call passes an 
                                  incorrect number of arguments 

`funtysMismatchTypeError.com`: tests that a semantic error is thrown when a function call passes in an 
                               argument of the wrong type

`hello-world.com`: tests that a simple "Hello World" program passes the type checking phase *without* errors

`ifbranchMismatchTypeError.com`: tests that a semantic error is thrown when there exists an `if` expression 
                                 where the true and false branch expressions do not have the same type

`ifcondMismatchTypeError.com`: tests that a semantic error is thrown when the conditional in an `if` expression 
                               is not a boolean

`matchOnNonCustomError.com`: tests that a semantic error is thrown when the expression in a `case` statement being 
                             matched on is not a custom datatype, but a pattern being matched on that expression is 
                             a custom datatype.

`mismatchAnnotatedArgnumError.com`: tests that a semantic error is thrown when the number of arguments in the type 
                                    annotation of a function does not match the number of arguments in the function 
                                    definition 

`mismatchAnnotationError.com`: tests that a semantic error is thrown when the type annotation of a function does not 
                               match the function type according to its definition 

`mismatchBranchError.com`: tests that a semantic error is thrown when different patterns in a case expression have 
                           different types

`mismatchBranchRHSError.com`: tests that a semantic error is thrown when expressions on the right hand side of case 
                              branches within a case expression have different types 

`mismatchTwoAnnotationsError.com`: tests that a semantic error is thrown when two type annotations are given for the 
                                   same function, but specify different function types 

`patternName.com`: tests that a program using a name as a pattern passes the type checking phase

`patternWarn.com`: tests that programs with non-exhaustative pattern matches or unreachable patterns pass the type, 
                   checking phase but throw a compiler warning

`redefinePrimitiveError.com`: tests that a semantic error is thrown when the user attempts to redefine a built-in 
                              primitive function such as `print-sym`

`unannotatedFuncError.com`: tests that a semantic error is thrown when a function is defined without a type annotation 

`unboundApplyNotFoundError.com`: tests that a semantic error is thrown when attempting to apply an unbound name as 
                                 a function

`unboundNameNotFoundError.com`: tests that a semantic error is thrown when attempting to consume a name that is not bound 

`unboundVConInCaseError.com`: tests that a semantic error is thrown when attempting to pattern match an instance of a 
                              custom datatype on an unbound variant constructor

MEMORY MANAGE TESTS (found in tests/mast/):

`case.com`: test for proper memory management in a simple case expression pattern matching on a custom intlist instance

`hello-world.com`: tests that a simple "Hello World" program passes the memory management stage 

`list.com`: test for proper memory management of duplication of a custom intlist 

LLVM TESTS (found in tests/llvm/):

`hello-world.com`: simple program that prints "Hello, World!"

`inf.com`: tests infinite mutual recursion of function calls 

`recurse.com`: tests infinite recursion of a function call 

RUN TESTS (found in tests/run/):

`add-or-sub.com`: Tests application of function that returns a primitive function 

`arith.com`: Tests primitive arithmetic operators including addition, 
             multiplication, and mod.

`bigdata.com`: Tests for proper implementation of datatype with a large number of 
               arguments to a variant constructor

`data.com`: Tests for proper creation and printing of a custom intlist datatype 

`datatypes.com`: Stress test that tests proper behavior for a variety of custom 
                 datatypes

`emoji.com`: Tests the use of an emoji as a name and the ability to 
             print a symbol containing an emoji. 

`even-odd.com`: Tests proper implementation of mutually recursive functions 

`fib.com`: Contains the implementation of a naive fibonacci algorithm 
           and computes the 35th fibonacci number.

`gcd.com`: Contains the implementation of Euclid's Algorithm to compute 
           the GCD of two numbers.

`hello-ho.com`: Prints "Hello, World!" with the use of higher order 
                functions. This is very much a flex. 

`hello-newline.com`: Prints "Hello, World!" followed by a newline character.

`hello-world.com`: Simply prints "Hello, World!"

`if.com`: Tests the proper usage of conditional (`if`) expressions.

`in.com`: Tests the ability to read user input via stdin. This program will 
          read in one character from stdin and print out the integer representation 
          of that character (according to the ASCII table).

`list.com`: Tests the ability to create and duplicate a custom intlist (*without* 
            printing it out)

`max.com`: Tests the ability to combine primitive comparison operators and if conditions 
           in a "max" function example.

`minidatatypes.com`: Tests for proper creation and printing of the elements of a 
                     custom intlist datatype

`nesteddatatypes.com`: Tests proper implementation of a large "chungus" type datatype,
                       with multiple layers of nesting

`nestedhofunctions.com`: Tests proper implementation of multiple layers of higher-order 
                         functions (e.g. a function that returns a function that returns 
                         a function)

`primitives.com`: Tests the vast majority of the primitive operators we supply 

`print.com`: Tests all four built-in print functions (print-int, print-bool, print-sym,
             and print-unit).

`quick_sort.com`: Simple quick sort program that utilizes higher-order functions, custom 
                  int-list datatype, and deep copying.

`return_func.com`: Program that tests the ability to apply a function returned from another 
                   function

`recurse.com`: Tests recursion functionality via a recursive "count-down" function.

`scope_names.com`: Tests that the same name used in different scopes is applied appropriately.

`tail.com`: Calls a recursive function that will result in a stack overflow
            without our tailcall optimization.

`val.com`: Tests correct application of `val` macros.

DEMO PROGRAMS (found in prog/):

`quicksort/quick_sort.com`: Defines an int-list datatype, constructs one, and sorts the list 
                            using the quicksort algorithm. Prints out the integers in the sorted 
                            list in order.

`quicksort/quicksort_c.com`
and 
`quicksort/quicksort_c.c`: Quick sort program where compost functions are called from C code.

`brainfuck/brainfuck.com`: An interpreter for the Brainfuck language (Turing complete);
                           pipe in a Brainfuck program followed by a `!` character 
                           followed by the desired input to that program in order to 
                           run it.

----------------------------------------------------------------------------------
Features not included in MicroC:

`hello-world.com` uses a symbol literal, which is not a feature in MicroC

`list.com` uses a custom list datatype, which cannot be done in MicroC

`hello-ho.com`: passes in a function as an argument to another function 

`emoji.com`: uses an emoji as a variable name, which cannot be done in MicroC

Guaranteed memory safety! (on the condition that users adhere to our consumption rule)

Top-level pattern matching for custom datatypes. 

----------------------------------------------------------------------------------
How test validates compilation or reports issues.

The tests compile the Compost program with our compiler, runs the executable 
(piping in input from the `.in` file via stdin if a `.in` file is present), 
and diffs the output against the `.out` file found in the subdirectory 
containing that test with the same name. The script reports that the test 
passed iff the output of the executable matches the output of the `.out` file,
and reports a test failure if there is a difference in the output. This 
is true of cases of successful compilation *and* cases where an error message 
is thrown (where the expected error message is in the `.out` file). 

