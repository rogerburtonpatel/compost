\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{changepage}
\usepackage{syntax}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS

\setlength{\parindent}{0cm}

\title{Pure Garbage: The Compost Language Reference Manual}

\author{}

\date{October 18, 2023}

\begin{document}

\maketitle

\begin{verbatim}
val name_email_map : (string * string) list =
[("Roger Burtonpatel", "roger.burtonpatel@tufts.edu");
 ("Randy Dang", "randy.dang@tufts.edu");
 ("Jasper Geer", "jasper.geer@tufts.edu");
 ("Jackson Warhover", "jackson.warhover@tufts.edu")]  
\end{verbatim}

% INTRODUCTION

\section{Introduction}
Compost is a statically-typed pure functional programming language with automatic compile-time memory management enabled by its uniqueness type system.

% NOTATIONAL CONVENTIONS

\section{Notational Conventions}

Code listings will appear in ``verbatim'' as follows:

\begin{verbatim}
(define foo ()
  bar)
\end{verbatim}
Grammar rules are written in extended Backus-Naur format, as follows:
\begin{grammar}
  <rule> ::= (<nonterminal> \texttt{terminal})
    \alt \{ <other-rule> \}
\end{grammar}

Parentheses are concrete syntax, but any pair of balanced parentheses may be freely exchanged for a pair of square brackets.
For example, the following two declarations are indistinguishable in the abstract syntax:

\begin{verbatim}
(val x 1)

[val x 1]
\end{verbatim}

Note that braces are used in a manner akin to the Kleene closure, that is, a term enclosed in brackets may be omitted or arbitrarily repeated.

% LEXICAL CONVENTIONS

\section{Lexical Conventions}

\subsection{Whitespace}

The following characters are considered as whitespace and, with one exception, ignored during tokenization:
spaces, tabs, carriage returns, and newlines.

\subsection{Comments}

Comments are introduced by the character \texttt{;} and terminated by the newline character.
Comments are treated as whitespace.

\subsection{Literals}

\begin{grammar}
  <literal> ::= <integer-literal>
  \alt <symbol-literal>
  \alt <boolean-literal>
  \alt <unit-literal>
\end{grammar}

Literals introduce values of Compost's primitive types.
All literals are valid expressions.

\subsection{Integer Literals}

\begin{grammar}
  <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.
\end{grammar}

The \texttt{+} prefix denotes a positive integer and the \texttt{-} prefix denotes a negative integer.
The characters \texttt{1 2 3 4 5 6 7 8 9 0} are considered digits.

\subsection{Symbol Literals}

\begin{grammar}
  <symbol-literal> ::= \texttt{'}\{ <symbol-character> \}\texttt{'}

  <symbol-character> ::= any unicode code point other than \texttt{'} and the backslash character unless escaped with a backslash.
\end{grammar}

That is, any sequence of \texttt{'}-delimited unicode characters is a valid symbol literal, as long as every instance of \texttt{'} or backslash are preceded by a backslash.
These escape sequences are replaced by their unescaped counterparts in the introduced symbol value.
For example, the following are valid symbol literals:

\begin{verbatim}
'\'hello, world\''

'\\ is a backslash'

'I exist
on multiple lines'
\end{verbatim}

\subsection{Other Literals}

\begin{grammar}
  <boolean-literal> ::= \texttt{true} | \texttt{false}

  <unit-literal> ::= \texttt{unit}
\end{grammar}

\subsection{Reserved Words}

The following tokens are considered reserved:
\begin{verbatim}
; ( ) [  ] : _ -> if val define datatype use case begin let dup int bool sym unit
\end{verbatim}

% VALUES

\section{Values}

This section describes the kinds of values manipulated by Compost programs.

\subsection{Integers}

Integer values are 32-bit signed integers with a range of -2,147,483,648 to 2,147,483,647.

\subsection{Symbols}

Symbol values are interned immutable strings of unicode characters.

\subsection{Booleans}

Boolean values are either the boolean \texttt{true} or the boolean \texttt{false}.

\subsection{Unit}

Unit values are all the value \texttt{unit}.

\subsection{Variant Values}

Variant values are either a constant constructor or a non-cosntant constructor applied to a series of value arguments.
We write an arbitrary constant constructor $const$ as $(const)$ and an arbitrary non-constant constructor $nonconst$ applied to arguments $v_1...v_{n}$ as $(nonconst\ v_{1}\ ...\ v_{n})$.

% NAMES

\section{Names}

\begin{grammar}
  <name> ::= any token that is not an \textit{int-lit}, does not contain a \texttt{'} or bracket, and is not a reserved word.
\end{grammar}


% TYPES

\section{Types}

\subsection{Type Expressions}

Syntactic forms in the \textit{type} category may appear in type annotations (see section 4.2.2) or to type datatype fields (see section 4.2.3).

\begin{grammar}

  <type> ::= (\texttt{->} (\{ <type> \}) <type>)
    \alt \texttt{int}
    \alt \texttt{bool}
    \alt \texttt{sym}
    \alt \texttt{unit}
    \alt <name>

\end{grammar}

Compost provides three primitive types.
These are \texttt{int}: 32-bit signed integers, \texttt{bool}: boolean values \texttt{true} or \texttt{false}, and \texttt{sym}: interned immutable strings.
In addition, there is a single type constructor, the \texttt{->} (arrow) type, which is used to construct the types of functions.
For example, the type of the \texttt{+} function, which returns the sum of two integers, would be:

\begin{verbatim}
(-> (int int) int)
\end{verbatim}

Within the pair of parentheses following the arrow are the types of the function's arguments, and the type following the closing parenthesis is the function's return type.
\\\\
Note that a type may be a name other than those of the primtive types.
Here the programmer can name a datatype, declared by the \texttt{datatype} form discussed in section 4.2.

% EXPRESSIONS

\section{Expressions}

\begin{grammar}
  <expr> ::= <literal>
    \alt <name>
    \alt <case-expression>
    \alt <if-expression>
    \alt <begin-expression>
    \alt <apply-expression>
    \alt <let-expression>
    \alt <dup-expression>
\end{grammar}

Meaningful computation is encoded in Compost as \textit{expr} syntactic forms, or expressions.
These appear either as the right-hand side of \texttt{val} declarations or as the bodies of functions.

\subsection{Literals}

The simplest expressions are literals, which introduce values of our primitive types.

\begin{grammar}

  <literal> ::= <int-lit>
    \alt <sym-lit>
    \alt <bool-lit>
    \alt \texttt{unit}

  <int-lit> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.

  <bool-lit> ::= \texttt{true} | \texttt{false}

  <sym-lit> ::= \texttt{'}\{ <sym-char> \}\texttt{'}

  <sym-char> ::= any unicode code point other than \texttt{'} unless escaped with a \texttt{\textbackslash}.

  <name> ::= any token that is not an \textit{int-lit}, does not contain a \texttt{'} or bracket, and is not one of the reserved words shown in typewriter font

\end{grammar}

Note the definitions of \textit{sym-char} and \textit{name}.
Compost imposes very few restrictions on the set of valid names.
For example, \texttt{.}, \texttt{1+1}, and \texttt{\$\#@!} are all valid names for functions, variables, and value constructors.
For characters found in symbols, we permit unicode code points along with the standard set of ASCII values.

\subsection{Case Expressions}

\begin{grammar}
  <case-expression> ::= (\texttt{case} <expr> (\{ <case-branch> \}))
\end{grammar}

\begin{grammar}
  <case-branch> ::= (<pattern> <expr>)

  <pattern> ::= (<name> \{ <name> | \texttt{_} \})
    \alt \texttt{_}
\end{grammar}

\subsection{If Expressions}

\begin{grammar}
  <if-expression> ::= (\texttt{if} <expr> <expr> <expr>)
\end{grammar}

\subsection{Begin Expressions}

\begin{grammar}
  <begin-expression> ::= (\texttt{begin} \{ <expr> \})
\end{grammar}

\subsection{Apply Expressions}

\begin{grammar}
  <apply-expression> ::= (<expr> \{ <expr> \})
\end{grammar}

\subsection{Let Expressions}

\begin{grammar}
  <let-expression> ::= (\texttt{let} (\{ <let-binding> \}) <expr>)

  <let-binding> ::= (<name> <expr>)
\end{grammar}

\subsection{Dup Expressions}

\begin{grammar}
  <dup-expression> ::= (\texttt{dup} <name>)
\end{grammar}

% DEFINITIONS

\section{Definitions}
Syntactic forms in the \textit{def} category are allowed only at the top level of a Compost program.

\begin{grammar}
  <def> ::= <val-binding>
    \alt <function-definition>
    \alt <datatype-definition>
    \alt <type-annotation>
    \alt <use-declaration>
\end{grammar}

\subsection{Global Bindings}

\begin{grammar}
  <val-binding> ::= (\texttt{val} <name> <exp>)
\end{grammar}

The \texttt{val} form introduces an immutable globally scoped binding.
Note that the bound name is in scope only in code located below the declaration.
For example the programmer may declare a global constant:

\begin{verbatim}
(val triangle-sides 3)
\end{verbatim}

Now, any successive code may use \texttt{triangle-sides} in place of the literal \texttt{3}.

\subsection{Function Definitions}

\begin{grammar}
  <function-definition> ::= (\texttt{define} <name> (\{ <name> \}) <exp>)
\end{grammar}

The \texttt{define} form defines a function in the global scope.
Any function may be referenced from any location in the program.
For example, the following introduces a function that returns the greater of its two arguments:

\begin{verbatim}
(define max (x y)
  (if (> x y)
      x
      y
  )
)
\end{verbatim}

The name directly following the \texttt{define} keyword is bound to the function in the global scope, and the list of names within the parentheses are bound, within the function body, to its arguments.
\\\\
Note that the order of function declarations does not matter.
Thus, the programmer may write mutually recursive programs like so:

\begin{verbatim}
(: is-even (-> (int) bool))
(define is-even (x)
  (if (= x 0)
      true
      (not (is-odd (- x 1)))
  )
)

(: is-odd (-> (int) bool))
(define is-odd (x)
  (if (= x 1)
      true
      (is-even (- x 1))
  )
)
\end{verbatim}

That is, despite \texttt{is-odd} being declared after \texttt{is-even}, \texttt{is-even} is in scope within the body of \texttt{is-odd}.

\subsection{Type Annotations}

\begin{grammar}
  <type-annotation> ::= (\texttt{:} <name> <type>)
\end{grammar}

Type annotations constrain the type of globally bound names.
In Compost, such names appear in two forms: the names of functions and names bound globally by \texttt{val}.
Take the definition of function \texttt{max} from the previous section.
We left out one key point, that this definition cannot stand on its own.
Each function definition must have a corresponding type annotation that gives its type.
This annotation may appear before or after its corresponding definition, but it must exist. For example, the definition of \texttt{max} may be succeeded by the following annotation:

\begin{verbatim}
(: max (-> (int int) int))
\end{verbatim}

That is, \texttt{max} is a function that takes two integer arguments and returns an integer.
Though the type of a function must be an ``arrow'' type, \texttt{->} may appear more than once in a function's type annotation.
For example, consider the following:

\begin{verbatim}
(: add-or-sub (-> (bool) (-> (int int) int)))
(define add-or-sub (cond)
  (if cond
      +
      -
  )
)
\end{verbatim}

Given that \texttt{+} and \texttt{-} are binary addition and subtraction on integers as defined in the initial basis, \texttt{add-or-sub} is a function that, given a boolean argument, returns a functions from pairs of integers to integers.
Note that Compost has no support for closures, so we cannot express the full range of higher-order functions.
\\\\
As mentioned, the other use of a type annotation is to type a \texttt{val}-bound name.
As with function definitions, all \texttt{val} bindings must have an associated type annotation.
However, the scoping rules here are more subtle.
Although a \texttt{val} binding's type annotation may be located before or after the binding itself, the bound name is in scope only after the \texttt{val} binding itself.
The location of the associated type annotation has no effect in this regard.

\subsection{Datatype Definitions}

\begin{grammar}
    <datatype-definition> ::= (\texttt{datatype} <name> (\{ <variant-constructor-definition> \}))

    <variant-constructor-definition> ::= (<name> (\{ <type> \}))
\end{grammar}

The \texttt{datatype} form allows the programmer to introduce new types.
The name of the new type appears directly following the \texttt{datatype} keyword, and this is followed by a list of variant constructor definitions.
Each of these provides a name for the constructor, followed by a list of types for its arguments.
Like functions, the placement of a datatype's definition has no bearing on where it can be referenced, introduced, or eliminated.
In fact, datatypes may be defined recursively, as in the following example:

\begin{verbatim}
(datatype int-list
  (
    [cons (int int-list)]
    [nil ()]
  )
)
\end{verbatim}

This declaration can be read as: ``an \texttt{int-list} is either a cons-cell containing an \texttt{int} and an \texttt{int-list}, or the empty list, \texttt{nil}''.
\\\\
Tags serve two purposes.
For every tag there exists a function of the same name which constructs a value of the corresponding datatype.
In addition, when top-level pattern matching on a value of a datatype, the pattern in each branch is prefixed by a different tag.
We will discuss top-level pattern matches in more detail in section 4, but here is an example using our already defined \texttt{int-list} datatype:

\begin{verbatim}
(: car (-> (intlist) int))
(define car (xxs)
  (case xxs
    ((cons x xs) x)
    ((nil) (error 'tried to take car of nil'))
  )
)

(: main (-> () unit)
(define main ()
  (let
    (
      [xs (cons 1 nil)]
      [y (car xs)]
    )
    (print-int y)
  )
)
\end{verbatim}

Here, \texttt{car} performs a top-level pattern match on its argument \texttt{xxs}.
If \texttt{xxs} was constructed with a call to \texttt{cons}, then the first element of that \texttt{cons} is returned.
Otherwise, if \texttt{xxs} was constructed with a call to \texttt{nil}, we err.
\texttt{main} then uses \texttt{cons} to construct an \texttt{intlist} from \texttt{1} and \texttt{nil} and calls \texttt{car} on the result.

\subsection{Use Declarations}

\begin{grammar}
  <use-declaration> ::= (\texttt{use} <filename>)
\end{grammar}

\section{Scoping Rules}

\section{Initial Basis}


\end{document}
