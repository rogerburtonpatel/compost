\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{changepage}
\usepackage{syntax}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS

\setlength{\parindent}{0cm}

\title{Pure Garbage: The Compost Language Reference Manual}

\author{}

\date{October 18, 2023}

\begin{document}

\maketitle

\begin{verbatim}
val name_email_map : (string * string) list =
[("Roger Burtonpatel", "roger.burtonpatel@tufts.edu");
 ("Randy Dang", "randy.dang@tufts.edu");
 ("Jasper Geer", "jasper.geer@tufts.edu");
 ("Jackson Warhover", "jackson.warhover@tufts.edu")]  
\end{verbatim}

% INTRODUCTION

\section{Introduction}
Compost is a statically-typed pure functional programming language with automatic compile-time memory management enabled by its uniqueness type system.

% NOTATIONAL CONVENTIONS

\section{Notational Conventions}

Code listings will appear in ``verbatim'' as follows:

\begin{verbatim}
(define foo ()
  bar)
\end{verbatim}

Grammar rules are written in extended Backus-Naur format, as follows:

\begin{grammar}
  <rule> ::= (<nonterminal> \texttt{terminal})
    \alt \{ <other-rule> \}
\end{grammar}

Parentheses are concrete syntax, but any pair of balanced parentheses may be freely exchanged for a pair of square brackets.
For example, the following two declarations are indistinguishable in the abstract syntax:

\begin{verbatim}
(val x 1)

[val x 1]
\end{verbatim}

Note that braces are used in a manner akin to the Kleene closure, that is, a term enclosed in brackets may be omitted or arbitrarily repeated.

% LEXICAL CONVENTIONS

\section{Lexical Conventions}

\subsection{Whitespace}

The following characters are considered as whitespace and, with one exception, ignored during tokenization:
spaces, tabs, carriage returns, and newlines.

\subsection{Comments}

Comments are introduced by the character \texttt{;} and terminated by the newline character.
Comments are treated as whitespace.

\subsection{Literals}

\begin{grammar}
  <literal> ::= <integer-literal>
  \alt <symbol-literal>
  \alt <boolean-literal>
  \alt <unit-literal>
\end{grammar}

Literals introduce values of Compost's primitive types.
All literals are valid expressions.

\subsection{Integer Literals}

\begin{grammar}
  <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.
\end{grammar}

The \texttt{+} prefix denotes a positive integer and the \texttt{-} prefix denotes a negative integer.
The characters \texttt{1 2 3 4 5 6 7 8 9 0} are considered digits.

\subsection{Symbol Literals}

\begin{grammar}
  <symbol-literal> ::= \texttt{'}\{ <symbol-character> \}\texttt{'}

  <symbol-character> ::= any unicode code point other than \texttt{'} and the backslash character unless escaped with a backslash.
\end{grammar}

That is, any sequence of \texttt{'}-delimited unicode characters is a valid symbol literal, as long as every instance of \texttt{'} or backslash are preceded by a backslash.
These escape sequences are replaced by their unescaped counterparts in the introduced symbol value.
For example, the following are valid symbol literals:

\begin{verbatim}
'\'hello, world\''

'\\ is a backslash'

'I exist
on multiple lines'
\end{verbatim}

\subsection{Other Literals}

\begin{grammar}
  <boolean-literal> ::= \texttt{true} | \texttt{false}

  <unit-literal> ::= \texttt{unit}
\end{grammar}

\subsection{Reserved Words}

The following tokens are considered reserved:
\begin{verbatim}
; ( ) [  ] : _ -> if val define datatype use case begin let dup int bool sym unit
\end{verbatim}

% VALUES

\section{Values}

This section describes the kinds of values manipulated by Compost programs.

\subsection{Integers}

Integer values are 32-bit signed integers with a range of -2,147,483,648 to 2,147,483,647.

\subsection{Symbols}

Symbol values are interned immutable strings of unicode characters.

\subsection{Booleans}

Boolean values are either the boolean $true$ or the boolean $false$.

\subsection{Unit}

Unit values are the value $unit$.

\subsection{Variant Values}

Variant values are either a constant constructor or a non-constant constructor applied to a series of value arguments.
We write an arbitrary constant constructor $c$ as $(c)$ and an arbitrary non-constant constructor $d$ applied to arguments $v_1...v_{n}$ as $(d\ v_{1}\ ...\ v_{n})$.
\\\\
Variant constructors are monomorphic, that is, for any constructor $c$, there exist types $\tau_{1}...\tau_{n}$ such that for any application of constructor $c$ to arguments $v_{1}...v_{n}$, $v_{i}$ must have type $\tau_{i}$ for all $i\in1...n$.

\subsection{Functions}

Functions in Compost are first-class objects.
Function values are mappings from ordered sets of values, to values.
That is, a function $f$, when applied to values $v_{1}...v_{n}$, produces a value $v_{r}$.
Like variant constructors, functions are monomorphic, so the types of $v_{1}...v_{n}$ and $v_{r}$ are fixed.

% NAMES

\section{Names}

Compost places relatively liberal constraints on the sequences of characters considered valid names.

\begin{grammar}
  <name> ::= any token that is not an \textit{int-lit}, does not contain whitespace, a \texttt{'}, bracket, or parenthesis, and is not a reserved word.
\end{grammar}

Names are bound to types, values, and variant constructors, and used to refer to them at various points in a program.
Names are also used in the \textit{use-declaration} syntactic form to refer to files.

% TYPE EXPRESSIONS

\section{Type Expressions}


\begin{grammar}

  <type-expression> ::= <function-type>
    \alt <int-type>
    \alt <bool-type>
    \alt <sym-type>
    \alt <unit-type>
    \alt <datatype>

\end{grammar}

\subsection{Primitive Types}

\begin{grammar}
  <int-type> ::= \texttt{int}

  <bool-type> ::= \texttt{bool}

  <sym-type> ::= \texttt{sym}

  <unit-type> ::= \texttt{unit}
\end{grammar}

\texttt{int} is the type of integer values.
\\\\
\texttt{bool} is the type of boolean values.
\\\\
\texttt{sym} is the type of symbol values.
\\\\
\texttt{unit} is the type of unit values.

\subsection{Function Types}

\begin{grammar}
  <function-type> ::= (\texttt{->} (\{ <type> \}) <type>)
\end{grammar}

$(\rightarrow (\tau_{1}\ ...\ \tau_{n})\ \tau_{r})$ is the type of function values which map ordered sets of values $v_{1}...v_{n}$ of types $\tau_{1}...\tau_{n}$ to values $v_{r}$ of type $\tau_{r}$.

\subsection{Datatypes}

\begin{grammar}
  <datatype> ::= <name>
\end{grammar}

Datatypes are the types of variant constructor values.
Multiple variant constructors may share the same type.
Datatypes and their constructors can be defined by the programmer with the following syntax:

\begin{grammar}
    <datatype-definition> ::= (\texttt{datatype} <name> (\{ <variant-constructor-definition> \}))

    <variant-constructor-definition> ::= (<name> (\{ <type-expression> \}))
\end{grammar}

A \textit{name} bound to the new type $\tau_{d}$ appears directly following the \texttt{datatype} keyword, and this is followed by a list of variant constructor definitions.
Each of these provides a \textit{name} bound to the constructor, $c$, followed by a list of \textit{type-expression}s $\tau_{1}...\tau_{n}$ typing its arguments.
Given this definition, a variant value $(c\ v_{1}\ ...\ v_{n})$ of type $\tau_{d} $ may be introduced by applying function value $c$ to $v_{1}...v_{n}$, where the type of $v_{i}$ is $\tau_{i}$ for all $i\in1...n$
\\\\
The placement of a datatype or variant constructor's definition has no bearing on where it can be referenced, introduced, or eliminated.
In fact, datatypes may be defined recursively, as in the following example:

\begin{verbatim}
(datatype int-list
  (
    [cons (int int-list)]
    [nil ()]
  )
)
\end{verbatim}

This declaration can be read as: ``an \texttt{int-list} is either \texttt{cons} applied to an \texttt{int} and an \texttt{int-list}, or \texttt{nil} applied to nothing''.

\section{Type System}

Compost is statically typed, with a monomorphic

% Tags serve two purposes.
% For every tag there exists a function of the same name which produces a variant constructor value.
% In this case, \texttt{cons}, when applied to values $v_{1},v_{2}$, produces $(\texttt{cons}\ v_{1}\ v_{2})$.
% In addition, when top-level pattern matching on a value of a datatype, the pattern in each branch is prefixed by a different tag.
% We will discuss top-level pattern matches in more detail in section 4, but here is an example using our already defined \texttt{int-list} datatype:

% \begin{verbatim}
% (: car (-> (intlist) int))
% (define car (xxs)
%   (case xxs
%     ((cons x xs) x)
%     ((nil) (error 'tried to take car of nil'))
%   )
% )

% (: main (-> () unit)
% (define main ()
%   (let
%     (
%       [xs (cons 1 nil)]
%       [y (car xs)]
%     )
%     (print-int y)
%   )
% )
% \end{verbatim}

% Here, \texttt{car} performs a top-level pattern match on its argument \texttt{xxs}.
% If \texttt{xxs} was constructed with a call to \texttt{cons}, then the first element of that \texttt{cons} is returned.
% Otherwise, if \texttt{xxs} was constructed with a call to \texttt{nil}, we err.
% \texttt{main} then uses \texttt{cons} to construct an \texttt{intlist} from \texttt{1} and \texttt{nil} and calls \texttt{car} on the result.



% EXPRESSIONS

\section{Expressions}

\begin{grammar}
  <expr> ::= <literal>
    \alt <name>
    \alt <case-expression>
    \alt <if-expression>
    \alt <begin-expression>
    \alt <apply-expression>
    \alt <let-expression>
    \alt <dup-expression>
\end{grammar}

Meaningful computation is encoded in Compost as \textit{expr} syntactic forms, or expressions.
These appear either as the right-hand side of \texttt{val} declarations or as the bodies of functions.
\\\\
We describe the semantics and typing rules of expressions largely informally but use formal notation to aid conciseness.
Expressions are evaluated in an environment $\rho$ mapping names to values.
Initially, these environments contain the values and types of all globally bound names (functions, \texttt{val}-bound names).
$\rho[x\mapsto v]$ is the modified environment $\rho$ in which name $x$ is bound to value $v$.
$\rho[x]$ is the value mapped to by $x$ in $\rho$.
\\\\
Certain expressions will ``consume'' names, though note that only names mapped to variant values are consumed.
That is, if a subsection states that ``if \texttt{e} is a name, it is consumed'', this should be interpreted as: ``if \texttt{e} is a name bound to a''
Consumption is defined inductively on the structure of expressions by the following subsections.

\subsection{Case Expressions}

\begin{grammar}
  <case-expression> ::= (\texttt{case} <expr> (\{ <case-branch> \}))

  <case-branch> ::= (<pattern> <expr>)

  <pattern> ::= (<name> \{ <name> | \texttt{_} \})
    \alt \texttt{_}
\end{grammar}
Values of the form $(c\ v_{1}\ ..\ v_{n})$ are eliminated by the \textit{case-expression} syntactic form.
Consider a case expression with $n$ branches of the form:

\begin{verbatim}
(case e
  (
    [(c1 v11 v12 ...) e1]
    ...
    [(cn vn1 vn2 ...) en]
  )
)
\end{verbatim}

Suppose evaluation of \texttt{e} in environment $\rho$ yields a value $v=(c\ v_{i}\ ...\ v_{m})$.
We assert that the type of \texttt{e} must be a datatype.
Each \texttt{c}$i$ where $i\in1...n$ must be a variant constructor of $\tau_{d}$.
If there exists some branch whose pattern is prefixed by $c$, we evaluate it in the modified environments $\Gamma',\rho$ identical to $\rho, \Gamma'$ but with every name consumed in \texttt{e} unbound, and yield the result.
\\\\
Suppose this branch is the \texttt{case-branch} containing the pattern prefixed by variant constructor \texttt{c}$k$.
Evaluation proceeds as follows.
Let $\tau_{1}...\tau_{m}$ be the types of $c$'s arguments.
We assert that number of names or wildcards \texttt{v}$ki$ following \texttt{c}$k$ must be precisely $m$.
Evaluation of this branch yields the result of evaluating \texttt{e}$k$ in the modified environments $\rho'[\texttt{v}k1\mapsto v_{1},...,\texttt{v}km\mapsto v_{m}]$. Note that we do not bind the wildcard symbol in $\rho'$.

\subsection{If Expressions}

\begin{grammar}
  <if-expression> ::= (\texttt{if} <expr> <expr> <expr>)
\end{grammar}

Consider an if expression of the form:

\begin{verbatim}
(if e1 e2 e3)
\end{verbatim}

Suppose evaluation of \texttt{e1} in environments $\rho$ yields a value $v$.
We assert that the type of \texttt{e1} must be \texttt{bool}.
Let


\subsection{Begin Expressions}

\begin{grammar}
  <begin-expression> ::= (\texttt{begin} \{ <expr> \})
\end{grammar}

\subsection{Apply Expressions}

\begin{grammar}
  <apply-expression> ::= (<expr> \{ <expr> \})
\end{grammar}

\subsection{Let Expressions}

\begin{grammar}
  <let-expression> ::= (\texttt{let} (\{ <let-binding> \}) <expr>)

  <let-binding> ::= (<name> <expr>)
\end{grammar}

\subsection{Dup Expressions}

\begin{grammar}
  <dup-expression> ::= (\texttt{dup} <name>)
\end{grammar}

% DEFINITIONS

\section{Definitions}
Syntactic forms in the \textit{def} category are allowed only at the top level of a Compost program.

\begin{grammar}
  <def> ::= <val-binding>
    \alt <function-definition>
    \alt <datatype-definition>
    \alt <type-annotation>
    \alt <use-declaration>
\end{grammar}

\subsection{Global Bindings}

\begin{grammar}
  <val-binding> ::= (\texttt{val} <name> <exp>)
\end{grammar}

The \texttt{val} form introduces an immutable globally scoped binding.
Note that the bound name is in scope only in code located below the declaration.
For example the programmer may declare a global constant:

\begin{verbatim}
(val triangle-sides 3)
\end{verbatim}

Now, any successive code may use \texttt{triangle-sides} in place of the literal \texttt{3}.

\subsection{Function Definitions}

\begin{grammar}
  <function-definition> ::= (\texttt{define} <name> (\{ <name> \}) <exp>)
\end{grammar}

The \texttt{define} form defines a function in the global scope.
Any function may be referenced from any location in the program.
For example, the following introduces a function that returns the greater of its two arguments:

\begin{verbatim}
(define max (x y)
  (if (> x y)
      x
      y
  )
)
\end{verbatim}

The name directly following the \texttt{define} keyword is bound to the function in the global scope, and the list of names within the parentheses are bound, within the function body, to its arguments.
\\\\
Note that the order of function declarations does not matter.
Thus, the programmer may write mutually recursive programs like so:

\begin{verbatim}
(: is-even (-> (int) bool))
(define is-even (x)
  (if (= x 0)
      true
      (not (is-odd (- x 1)))
  )
)

(: is-odd (-> (int) bool))
(define is-odd (x)
  (if (= x 1)
      true
      (is-even (- x 1))
  )
)
\end{verbatim}

That is, despite \texttt{is-odd} being declared after \texttt{is-even}, \texttt{is-even} is in scope within the body of \texttt{is-odd}.

\subsection{Type Annotations}

\begin{grammar}
  <type-annotation> ::= (\texttt{:} <name> <type-expression>)
\end{grammar}

Type annotations constrain the type of globally bound names.
In Compost, such names appear in two forms: the names of functions and names bound globally by \texttt{val}.
Take the definition of function \texttt{max} from the previous section.
We left out one key point, that this definition cannot stand on its own.
Each function definition must have a corresponding type annotation that gives its type.
This annotation may appear before or after its corresponding definition, but it must exist. For example, the definition of \texttt{max} may be succeeded by the following annotation:

\begin{verbatim}
(: max (-> (int int) int))
\end{verbatim}

That is, \texttt{max} is a function that takes two integer arguments and returns an integer.
Though the type of a function must be an ``arrow'' type, \texttt{->} may appear more than once in a function's type annotation.
For example, consider the following:

\begin{verbatim}
(: add-or-sub (-> (bool) (-> (int int) int)))
(define add-or-sub (cond)
  (if cond
      +
      -
  )
)
\end{verbatim}

Given that \texttt{+} and \texttt{-} are binary addition and subtraction on integers as defined in the initial basis, \texttt{add-or-sub} is a function that, given a boolean argument, returns a functions from pairs of integers to integers.
Note that Compost has no support for closures, so we cannot express the full range of higher-order functions.
\\\\
As mentioned, the other use of a type annotation is to type a \texttt{val}-bound name.
As with function definitions, all \texttt{val} bindings must have an associated type annotation.
However, the scoping rules here are more subtle.
Although a \texttt{val} binding's type annotation may be located before or after the binding itself, the bound name is in scope only after the \texttt{val} binding itself.
The location of the associated type annotation has no effect in this regard.

\subsection{Use Declarations}

\begin{grammar}
  <use-declaration> ::= (\texttt{use} <filename>)
\end{grammar}

\section{Scoping Rules}

\section{Initial Basis}


\end{document}
