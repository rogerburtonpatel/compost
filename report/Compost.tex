\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{changepage}
\usepackage{syntax}

\newcommand\op{\texttt{(}}
\newcommand\cl{\texttt{)}}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS

\setlength{\parindent}{0cm}

\hypersetup{
    colorlinks=true,
    linktoc=all, 
    linkcolor=blue,
    urlcolor=blue
}

\title{Compost Final Report}

\author{}

\date{December 15, 2023}

\begin{document}

\maketitle

\begin{verbatim}
val name_email_map : (string * string) list =
[("Roger Burtonpatel", "roger.burtonpatel@tufts.edu");
 ("Randy Dang", "randy.dang@tufts.edu");
 ("Jasper Geer", "jasper.geer@tufts.edu");
 ("Jackson Warhover", "jackson.warhover@tufts.edu")]  
\end{verbatim}

\tableofcontents

\pagebreak

% INTRODUCTION

\section{Introduction} {
    Compost is a statically-typed pure functional programming language with an affine type system.
    That is, the type system guarantees that no two live references ever exist to the same heap object.
    Programs in Compost include no explicit memory management and run without the need for
    a runtime garbage collector. This is because in a manner akin to Rust, the Compost compiler 
    performs compile-time memory management, inserting memory-freeing directives and guaranteeing memory 
    safety for all Compost programs.
    \\\\
    In order to make this guarantee, we must place one major restriction on the programmer to ensure 
    that the compiler is performing a decidable task: each variable can be used at most once in a 
    given scope. That is, if a variable \textbf{could} have been referenced already in the current 
    scope, the programmer is not allowed to reference it again. When we enforce this restriction, we 
    can determine the point at which a variable in scope will not be used and insert free directives 
    accordingly.
    \\\\
    A memory safe language is useful because it guarantees that memory-related bugs will never be 
    introduced by programmers; any such errors would be caught by the compiler ahead of time. This 
    is an especially handy feature when writing implementations of critical systems (such as medical 
    devices) where memory-related bugs could potentially be very costly. The lack of a need for 
    automatic garbage collection also leads to better performance. 
}

% LANGUAGE TUTORIAL

\section{Language Tutorial} {
    This section contains a brief tutorial of how to write simple programs in Compost utilizing some 
    of the more important features. For a full specification of the language, see the 
    \hyperref[sec:lrm]{Language Manual}.
}

\subsection{Notational Convention} {
    In this section and the rest of this document, code listings will appear in ``verbatim'' as follows:
    \begin{verbatim}
(define foo ()
    bar)
    \end{verbatim}
}

\subsection{Compost Basics} {
    Compost is a parenthesized functional language with a syntax similar to Scheme syntax, but it is 
    a compiled language rather than interpreted. A Compost program consists of a sequence of definitions, 
    which mainly include preprocessor macros, function definitions, and custom datatype definitions. For 
    every function definition, there must also exist a type annotation that 
    defines the argument and return types of that function. The function with name \texttt{main} defines 
    the entry point of the program, and it must take in no arguments and return type \texttt{unit}.  
    \\\\
    Function definitions are specified via the \texttt{define} keyword. Here is a program that simply 
    prints the string ``Hello, World!'' (\texttt{print-sym} is a built-in function that takes in a 
    single symbol argument and prints it to stdout, and any character between a semicolon and the 
    end of a line, inclusive, is part of a comment). 
    \begin{verbatim}
(: main (-> () unit)) ;; type annotation: defines `main' as function taking no 
                      ;; arguments and returning type `unit'
(define main ()                   ;; definition for `main' function, the entry 
                                  ;; point of the program
    (print-sym 'Hello, World!'))  ;; prints out `Hello, World' symbol
    \end{verbatim}

    Preprocessor macros are specified via the \texttt{val} keyword and can improve code readability 
    and/or reduce code duplication. This program uses a preprocessor macro to accomplish the same 
    functionality as above:
    \begin{verbatim}
(val hello-str 'Hello, World!') ;; defines the name `hello-str' as the string 
                                ;; 'Hello, World!'
                                ;; This is analogous to the following in C: 
                                ;; #define hello-str "Hello, World!"
(: main (-> () unit)) ;; type annotation
(define main () ;; program entry point
    (print-sym hello-str))  ;; prints out `Hello, World' symbol
    \end{verbatim}

    Functions are called in the same manner as they are in Scheme. Here is an example of the definiton of
    a function \texttt{compute} that performs arithmetic on two numbers and a \texttt{main} function that 
    calls compute, passing in \texttt{2} and \texttt{3} as arguments.
    \begin{verbatim}
(: compute (-> (int int) int)) ;; type annotation: defines `compute' as a 
                               ;; function taking in two ints as arguments
                               ;; and returns an int 
(define compute (x y)
    (+ (* x 2) y)) ;; multiply x by 2 and add y. Prefix arithmetic operators 
                   ;; are built-in 

(: main (-> () unit)) ;; type annotation 
(define main () ;; program entry point 
    (print-int (compute 2 3))) ;; prints the result of calling `compute' on 
                               ;; the numbers 2 (bound to `x') and 3 (bound 
                               ;; to `y'), as an integer. Result should be 
                               ;; 7. 
    \end{verbatim}
}

\subsection{Custom Datatypes} {
    The most interesting functionality provided to the user is the ability to define and use custom 
    abstract data types. Such datatypes can be defined with the \texttt{datatype} keyword and the 
    definitions of one or more variant constructors, which define ways that instances of that datatype 
    can be created. For example, a linked list of integers can be defined as follows:
    \begin{verbatim}
;; Definition of linked list of integers, which can be constructed in two 
;; ways (one defines the case of a non-empty list, and the other defines 
;; the case of an empty list)
(datatype int-list 
    ([cons-int (int int-list)] ;; Variant constructor 1: create a non-empty 
                               ;; int-list by applying `cons-int' to an int 
                               ;; and another int-list.
     [nil-int-list ()]))       ;; Variant constructor 2: create an empty 
                               ;; int-list by applying `nil-int-list' to 
                               ;; nothing 
    \end{verbatim}
    If this datatype definition exists somewhere in the program, then 
    \texttt{int-list} exists as a type and both \texttt{cons-int} and 
    \texttt{nil-int-list} exist as constructors that can be called.
    \\\\
    For example, a three-element linked list can be constructed as follows:
    \begin{verbatim}
;; macro that constructs linked list with elements: [0, 1, 2]
(val len3list (cons-int 0 (cons-int 1 (cons-int 2 (nil-int-list)))))
    \end{verbatim}
    To ``unpack'' the components of a custom datatype within a function, we support top-level pattern 
    matching on the variant constructor definitions via \texttt{case} expressions. For example, below 
    is a function that gets the length of an \texttt{int-list}.
    \begin{verbatim}
;; Gets length of int-list `xxs' in terms of number of elements 
(: len-int-list (-> (int-list) int)) ;; type annotation: takes in an int-list 
                                     ;; as input and returns an int 
(define len-int-list (xxs) ;; binds argument to name `xxs'
    (case xxs ;; begins pattern matching on the int-list `xxs'
        ([(cons-int x xs) ;; specify non-empty case with appropriate variant 
                          ;; constructor 
            (+ 1 (len-int-list xs))] ;; expression to evaluate in non-empty 
                                     ;; case (add 1 to length of sub-list `xs')
         [(nil-int-list) ;; specify empty case with appropriate variant 
                         ;; constructor
            0]))) ;; expression to evaluate in empty case (length is just 0)
    \end{verbatim} 
    
    If we wanted to print the length of \texttt{len3list} in our driver, we can do so as follows:
    \begin{verbatim}
(: main (-> () unit)) ;; type annotation
(define main () ;; program entry point 
    (print-int (len-int-list len3list))) ;; prints number of elements in 
                                         ;; `len3list'. Should print 3.
    \end{verbatim}
}

\subsection{How to Use Compiler} {
    To use our compiler to compile Compost code, there should be a script called \texttt{gcc} (which 
    stands for ``Good Compost Compiler'') in the top-level directory. Ensure that \texttt{cc} is 
    symlinked to some version of \texttt{clang}, and simply execute that script as such:
    \begin{verbatim}
./gcc file.com
    \end{verbatim}

    where \texttt{file.com} is the name of a file containing a Compost program. An executable with the 
    same name but the extension removed (\texttt{file} in the above case) will appear in the same directory 
    as the Compost program. Run the compiled executable with:
    \begin{verbatim}
./file
    \end{verbatim}

    With the above example, our \texttt{gcc} script internally runs the following command:
    \begin{verbatim}
dune exec compost file.com | llc -relocation-model=pic | cc -x assembler -o file -
    \end{verbatim}
}

% LRM
\section{Language Manual} 
\label{sec:lrm}

\subsection{Introduction} {
    This language reference manual contains a formal description of Compost's syntax, along with an informal description of its semantics and type system.
    In addition, an initial basis for Compost programs is outlined.
}

% NOTATIONAL CONVENTIONS

\subsection{More Notational Conventions}

Grammar rules are written in extended Backus-Naur format, as follows:

\begin{grammar}
  <rule> ::= (<nonterminal> \texttt{terminal})
    \alt \{ <other-rule> \}
\end{grammar}

Parentheses are concrete syntax, but any pair of balanced parentheses may be freely exchanged for a pair of square brackets.
For example, the following two declarations are indistinguishable in the abstract syntax:

\begin{verbatim}
(val x 1)

[val x 1]
\end{verbatim}

Note that braces are used in a manner akin to the Kleene closure, that is, a term enclosed in braces may be omitted or arbitrarily repeated.

% LEXICAL CONVENTIONS

\subsection{Lexical Conventions}

\subsubsection{Whitespace}

The following characters are considered as whitespace and, with one exception, ignored during tokenization:
spaces, tabs, carriage returns, and newlines.

\subsubsection{Comments}

Comments are introduced by the character \texttt{;} and terminated by the newline character.
Comments are treated as whitespace.

\subsubsection{Literals}

\begin{grammar}
  <literal> ::= <integer-literal>
  \alt <symbol-literal>
  \alt <boolean-literal>
  \alt <unit-literal>
\end{grammar}

Literals introduce values of Compost's primitive types.
All literals are valid expressions.

\subsubsection{Integer Literals}

\begin{grammar}
  <integer-literal> ::= token composed only of digits, possibly prefixed with a \texttt{+} or \texttt{-}.
\end{grammar}

The \texttt{+} prefix denotes a positive integer and the \texttt{-} prefix denotes a negative integer.
The characters \texttt{1 2 3 4 5 6 7 8 9 0} are considered digits.

\subsubsection{Symbol Literals}

\begin{grammar}
  <symbol-literal> ::= \texttt{'}\{ <symbol-character> \}\texttt{'}

  <symbol-character> ::= any unicode code point other than \texttt{'} and the backslash character unless escaped with a backslash.
\end{grammar}

That is, any sequence of \texttt{'}-delimited unicode characters is a valid symbol literal, as long as every instance of \texttt{'} or backslash are preceded by a backslash.
This includes characters that would otherwise be treated as whitespace if they were found outside of the symbol literal setting. Escape sequences are replaced by their 
unescaped counterparts in the introduced symbol value. For example, the following are valid symbol literals:

\begin{verbatim}
'\'hello, world\''

'\\ is a backslash'

'I exist
on multiple lines'
\end{verbatim}

The following are \textit{not} valid symbol literals:

\begin{verbatim}
'Pini's Pizzeria' ;; the apostraphe should be escaped 

'\ is missing an escape backslash'

'This is not a newline character: \n' ;; see above for proper usage of 
                                      ;; multi-line strings
\end{verbatim}

\subsubsection{Other Literals}

\begin{grammar}
  <boolean-literal> ::= \texttt{true} | \texttt{false}

  <unit-literal> ::= \texttt{unit}
\end{grammar}

\subsubsection{Reserved Words}

The following tokens are considered reserved:
\begin{verbatim}
; ( ) [  ] : _ -> if val define datatype use case begin let dup int bool sym unit
\end{verbatim}

% VALUES

\subsection{Values}

This section describes the kinds of values manipulated by Compost programs.

\subsubsection{Integers}

Integer values are 32-bit signed integers with a range of -2,147,483,648 to 2,147,483,647.

\subsubsection{Symbols}

Symbol values are interned immutable strings of unicode characters.

\subsubsection{Booleans}

Boolean values are either the boolean \texttt{true} or the boolean \texttt{false}.

\subsubsection{Unit}

Unit values are the value \texttt{unit}.

\subsubsection{Variant Values}

Variant values are either a constant constructor or a non-constant constructor applied to a series of value arguments.
We write an arbitrary constant constructor $c$ as $(c)$ and an arbitrary non-constant constructor $d$ applied to arguments $v_1...v_{n}$ as $(d\ v_{1}\ ...\ v_{n})$.
\\\\
Variant constructors are monomorphic, that is, for any constructor $c$, there exist types $\tau_{1}...\tau_{n}$ such that for any application of constructor $c$ to arguments $v_{1}...v_{n}$, $v_{i}$ must have type $\tau_{i}$ for all $i\in1,2,...,n$.

\subsubsection{Functions}

Functions in Compost are globally defined objects. They can be passed in to other functions or returned from 
functions. 
Function values are mappings from ordered sets of values, to values.
That is, a function $f$, when applied to values $v_{1}...v_{n}$, produces a value $v_{r}$.
Like variant constructors, functions are monomorphic, so the types of $v_{1}...v_{n}$ and $v_{r}$ are fixed.

% NAMES

\subsection{Names}

Compost places relatively liberal constraints on the sequences of characters considered valid names.

\begin{grammar}
  <name> ::= any token that is not an \textit{int-lit}, does not contain whitespace (including a \texttt{;} character indicating the start of a comment), a \texttt{'}, bracket, or parenthesis, and is not a reserved word.
\end{grammar}

Names are bound to datatypes, functions, values, and variant constructors, and are used to refer to them at various points in a program.

% TYPE EXPRESSIONS

\subsection{Type Expressions}


\begin{grammar}

  <type-expression> ::= <function-type>
    \alt <int-type>
    \alt <bool-type>
    \alt <sym-type>
    \alt <unit-type>
    \alt <datatype>

\end{grammar}

\subsubsection{Primitive Types}

\begin{grammar}
  <int-type> ::= \texttt{int}

  <bool-type> ::= \texttt{bool}

  <sym-type> ::= \texttt{sym}

  <unit-type> ::= \texttt{unit}
\end{grammar}

\texttt{int} is the type of integer values.
\\\\
\texttt{bool} is the type of boolean values.
\\\\
\texttt{sym} is the type of symbol values.
\\\\
\texttt{unit} is the type of unit values.

\subsubsection{Function Types}

\begin{grammar}
  <function-type> ::= (\texttt{->} (\{ <type> \}) <type>)
\end{grammar}

\texttt{(-> (t1 ... tn) tr)} is the type of function values which map ordered sets of values $v_{1}...v_{n}$ of types $\texttt{t}1...\texttt{t}n$ to value $v_{r}$ of type $\texttt{tr}$.

\subsubsection{Datatypes}

\begin{grammar}
  <datatype> ::= <name>
\end{grammar}

Datatypes are the types of variant constructor values.
Multiple variant constructors may share the same type.
Datatypes and their constructors can be defined by the programmer with the following syntax:

\begin{grammar}
    <datatype-definition> ::= (\texttt{datatype} <name> (\{ <variant-constructor-definition> \}))

    <variant-constructor-definition> ::= (<name> (\{ <type-expression> \}))
\end{grammar}

A \textit{name} bound to the new type $\tau_{d}$ appears directly following the \texttt{datatype} keyword, and this is followed by a list of variant constructor definitions.
Each of these provides a \textit{name} bound to the constructor, $c$, followed by a list of \textit{type-expression}s $\tau_{1}...\tau_{n}$ typing its arguments.
Given this definition, a variant value $(c\ v_{1}\ ...\ v_{n})$ of type $\tau_{d} $ may be introduced by applying function value $c$ to $v_{1}...v_{n}$, where the type of $v_{i}$ is $\tau_{i}$ for all $i\in1,2,...,n$
\\\\
The placement of a datatype or variant constructor's definition has no bearing on where it can be referenced, introduced, or eliminated.
In fact, datatypes may be defined recursively, as in the following example:

\begin{verbatim}
(datatype int-list
  ([cons (int int-list)]
    [nil ()]))
\end{verbatim}

This declaration can be read as: ``an \texttt{int-list} is either \texttt{cons} applied to an \texttt{int} and an \texttt{int-list}, or \texttt{nil} applied to nothing''.
\\\\

% EXPRESSIONS

\subsection{Expressions}

\begin{grammar}
  <expr> ::= <literal>
    \alt <case-expression>
    \alt <if-expression>
    \alt <begin-expression>
    \alt <apply-expression>
    \alt <let-expression>
    \alt <dup-expression>
    \alt <name-expression>
\end{grammar}

Meaningful computation is encoded in Compost as \textit{expr} syntactic forms, or expressions.
These appear either as the right-hand side of \texttt{val} definitions (i.e. preprocessor 
macros) or as the bodies of functions.
\\\\
We describe the semantics and typing rules of expressions largely informally but use formal notation to aid conciseness.
Expressions are evaluated in an environment $\rho$ mapping names to values.
Initially, these environments contain the values and types of all globally bound names (functions and \texttt{val}-bound names).
$\rho[x\mapsto v]$ is the modified environment $\rho$ in which name $x$ is bound to value $v$.
$\rho[x]$ is the value mapped to by $x$ in $\rho$.
\\\\
There also exists a typing environment $\Gamma$ mapping names to types.
The same syntax is used to add bindings to $\Gamma$ and denote the type mapped to by a name $x$.
We also introduce a typing judgement $\Gamma\vdash e:\tau$ which can be read as ``expression $e$ has type $\tau$ in context $\Gamma$''.
When $\Gamma$ is used in a subsection, it refers to the environment in which that particular expression is typed, rather than the initial typing environment.
This typing judgement is defined inductively on the structure of expressions by the following subsections.
\\\\
Certain expressions will ``consume'' names, effectively moving them out of scope.
As a rule of thumb, any name that can be consumed can only be consumed once in a given program path of execution.
Any names considered as consumed in a subexpression are considered consumed in the parent expression.
Consumption is defined inductively on the structure of expressions by the following subsections.
\\\\
Side effects are produced in evaluation order except in the case of \texttt{val}-bound names, which produce their associated expression's side effects at \textbf{every} reference.

\subsubsection{Case Expressions}

\begin{grammar}
  <case-expression> ::= (\texttt{case} <expr> (\{ <case-branch> \}))

  <case-branch> ::= (<pattern> <expr>)

  <pattern> ::= (<name> \{ <name> | \texttt{_} \})
    \alt \texttt{_}
\end{grammar}
Note that we refer to instance of \texttt{_} in patterns as ``wildcards''.
Values of the form $(c\ v_{1}\ ..\ v_{n})$ are eliminated by the \textit{case-expression} syntactic form.
Consider a case expression with $n$ branches of the form:

\begin{verbatim}
(case e
  ([(c1 v11 v12 ...) e1]
    ...
    [(cn vn1 vn2 ...) en]))
\end{verbatim}

\textbf{Typing}

We assert that the type of \texttt{e} must be a datatype.
Suppose that $\Gamma\vdash\texttt{e}:\tau_{d}$.
Each \texttt{c}$i$ must be a variant constructor of $\tau_{d}$.
For all $i\in1,2,...,n$, let $\tau_{i1},\tau_{i2},...,\tau_{im}$ be the types of \texttt{c}$i$'s $m$ arguments.
We assert that the number of names and wildcards following \texttt{c}$i$ must be precisely $m$. If any one of 
these names is not fresh (i.e. is already bound in a larger scope), then it shadows the existing binding in 
expression \texttt{e}$i$. 
Let $\Gamma_{i}$ be $\Gamma[\texttt{v}i1\mapsto\tau_{i1},...,\texttt{v}im\mapsto\tau_{im}]$.
Note that wildcards are not bound.
We assert that $\Gamma_{i}\vdash\texttt{e}i:\tau_{r}$.
The type of the full \texttt{case} expression in context $\Gamma$ is $\tau_{r}$.
\\\\
\textbf{Consumption}

Names marked as consumed in \texttt{e} are marked as consumed in all \texttt{e}$i$. Names marked as consumed in 
any \texttt{e}$i$ are marked as consumed in the full \texttt{case} expression, but are \textit{not} marked as 
consumed in any \texttt{e}$j$ where $j\in1,2,...,n$ and $j\neq i$.
\\\\
\textbf{Evaluation}

Suppose evaluation of \texttt{e} in environment $\rho$ yields a value $v=(c\ v_{i}\ ...\ v_{m})$.
If there exists some branch whose pattern is prefixed by $c$, it is evaluated in the environment $\rho$ and its result is returned.
Otherwise, a the program halts with a runtime error.
\\\\
Suppose this branch is the \textit{case-branch} containing the pattern prefixed by variant constructor \texttt{c}$k$.
Evaluation of this branch yields the result of evaluating \texttt{e}$k$ in the modified environment $\rho'=\rho[\texttt{v}k1\mapsto v_{1},...,\texttt{v}km\mapsto v_{m}]$. Note that we do not bind wildcards in $\rho'$.

\subsubsection{If Expressions}

\begin{grammar}
  <if-expression> ::= (\texttt{if} <expr> <expr> <expr>)
\end{grammar}

Consider an if expression of the form:

\begin{verbatim}
(if e1 e2 e3)
\end{verbatim}

\textbf{Typing}

We assert that $\Gamma\vdash\texttt{e1}:\texttt{bool}$.
We further assert that $\Gamma\vdash\texttt{e2}:\tau_{r}$ and $\Gamma\vdash\texttt{e3}:\tau_{r}$.
The type of the full \texttt{if} expression in context $\Gamma$ is $\tau_{r}$.
\\\\
\textbf{Consumption}

Names marked as consumed in \texttt{e1} are marked as consumed in \texttt{e2} and \texttt{e3}. Names marked as consumed 
in any of \texttt{e1}, \texttt{e2}, or \texttt{e3} are marked as consumed in the full \texttt{if} expression, but names 
marked as consumed in \texttt{e2} are \textit{not} marked as consumed in \texttt{e3}.
\\\\
\textbf{Evaluation}

Suppose the evaluation of \texttt{e1} in environment $\rho$ yields a boolean value $v$.
If $v$ is the value \texttt{true}, the expression \texttt{e2} is evaluated in environment $\rho$ and its result is returned.
If $v$ is the value \texttt{false}, the expression \texttt{e3} is evaluated in environment $\rho$ and its result is returned.

\subsubsection{Begin Expressions}

\begin{grammar}
  <begin-expression> ::= (\texttt{begin} \{ <expr> \})
\end{grammar}

Consider a begin expression of the form:

\begin{verbatim}
(begin e1 ... en)
\end{verbatim}

\textbf{Typing}

The type of this expression is the type of \texttt{en}.
\\\\
\textbf{Consumption}

For all $i\in1,2,...,n-1$, names marked as consumed in \texttt{e}$i$ are marked as consumed in \texttt{e}($i+1$).
\\\\
\textbf{Evaluation}

Each \texttt{e}$i$ is evaluated in environment $\rho$ in order from $1...n$.
We return the result of evaluating \texttt{e}$n$ in environment $\rho$.

\subsubsection{Apply Expressions}

\begin{grammar}
  <apply-expression> ::= (<expr> \{ <expr> \})
\end{grammar}

Consider an apply expression of the form:

\begin{verbatim}
(e e1 ... en)
\end{verbatim}

\textbf{Typing}

We assert that $\Gamma\vdash\texttt{e}:\texttt{(-> (}t_{1}\ ...\ t_{n}\texttt{)}\ t_{r}\texttt{)}$.
Each \texttt{e}$i$ must be of type $t_{i}$ for $i\in1,2,...,n$.
The type of this apply expression is $t_{r}$.
\\\\
\textbf{Consumption}

For all $i\in1,2,...,n-1$, names marked as consumed in \texttt{e}$i$ are marked as consumed in \texttt{e}$i+1$.
\\\\
\textbf{Evaluation}

Each \texttt{e}$i$ is evaluated in environment $\rho$ in order from $1...n$.
Let $v_{1}...v_{n}$ be the values returned by evaluating each \texttt{e}$i$.
\\\\
We return the result of applying \texttt{e} to arguments $v_{1}...v_{n}$.

\subsubsection{Let Expressions}

\begin{grammar}
  <let-expression> ::= (\texttt{let} (\{ <let-binding> \}) <expr>)

  <let-binding> ::= (<name> <expr>)
\end{grammar}

Consider a let expression of the form:

\begin{verbatim}
(let
  ([x1 e1]
    ...
    [xn en])
  e)
\end{verbatim}

\textbf{Typing}

Given that $\Gamma_{k}:\texttt{x}k:\tau_{k}$, for $k\in1,2,...,n$, we say that $\Gamma_{k+1}=\Gamma_{k}[\texttt{x}k\mapsto\tau_{k}]$.
As a base case, let $\Gamma_{1}=\Gamma$.
The type of this \texttt{let} expression is the type of \texttt{e} in context $\Gamma_{n+1}$.
\\\\
\textbf{Consumption}

For any $i\in1,2,...,n$ we mark any names consumed in \texttt{e}$i$ as consumed in both \texttt{e} and all \texttt{e}$k$ for $k>i$.
\\\\
\textbf{Evaluation}

For all $i\in1,2,...,n$, let $\rho_{i+1}=\rho_{i}[\texttt{x}i\mapsto v_{i}]$, where $v_{i}$ is the value returned by evaluating \texttt{e}$i$ in environment $\rho_{i}$.
As a base case, let $\rho_{1}=\rho$.
We return the result of evaluating \texttt{e} in environment $\rho_{n+1}$.

\subsubsection{Name Expressions}

\begin{grammar}
  <name-expression> ::= <name>
\end{grammar}

Consider a name expression of the form:

\begin{verbatim}
n
\end{verbatim}

\textbf{Typing}

We assert that \texttt{n} be bound in $\Gamma$.
We further assert that \texttt{n} not be marked as consumed.
The type of this expression is $\Gamma[\texttt{n}]$. 
\\\\
\textbf{Consumption}

If the type of \texttt{n} in context $\Gamma$ is a datatype, it is marked as consumed.
\\\\
\textbf{Evaluation}

We return the value $\rho[\texttt{n}]$.

\subsection{Dup Expressions}

\begin{grammar}
  <dup-expression> ::= (\texttt{dup} <name>)
\end{grammar}

Consider a dup expression of the form:

\begin{verbatim}
(dup n)
\end{verbatim}

\textbf{Typing}

We assert that \texttt{n} be bound in $\Gamma$.
We further assert that \texttt{n} not be marked as consumed.
The type of this expression is $\Gamma[\texttt{n}]$. 
\\\\
\textbf{Consumption}

\texttt{n} is \textbf{not} marked as consumed.
\\\\
\textbf{Evaluation}

We return the value $\rho[\texttt{n}]$. If $\Gamma[\texttt{n}]$ is a datatype, the 
returned value is a deep copy.

% DEFINITIONS

\subsection{Definitions}
Syntactic forms in the \textit{def} category are allowed only at the top level of a Compost program.

\begin{grammar}
  <def> ::= <val-binding>
    \alt <function-definition>
    \alt <datatype-definition>
    \alt <type-annotation>
    \alt <use-declaration>
\end{grammar}

We retain the environment notation conventions from the previous subsection.
\\\\
Compost maintains a global $\Gamma_{g}$ and $\rho_{g}$ which are mutated by type annotations, \texttt{val} bindings, and function definitions.
Additional bindings may be added to these environments at code points.
A change to either of these global environments at a given code point is reflected at all succeeding code points.
To determine the initial $\Gamma$ or $\rho$ at a \texttt{val} binding or function definition, we take the $\Gamma_{g}$ and $\rho_{g}$ at its opening parenthesis.
\subsubsection{Type Annotations}

\begin{grammar}
  <type-annotation> ::= (\texttt{:} <name> <type-expression>)
\end{grammar}

Type annotations constrain the type of globally bound function names.
Each such function name must have an associated type annotation.
Consider a type annotation of the form:

\begin{verbatim}
(: n t)
\end{verbatim}

We bind \texttt{n} to \texttt{t} in $\Gamma_{g}$ at the first character of the file, i.e. the entire program has access to 
this binding regardless of where the the function \texttt{n} is defined.

% Commented out, this seems outdated
% If \texttt{n} is bound by \texttt{define}, then we bind \texttt{n} to \texttt{t} in $\Gamma_{g}$ at the first character of the file.
% If \texttt{n} is bound by \texttt{val}, then we bind \texttt{n} to \texttt{t} in $\Gamma_{g}$ at the closing parenthesis of the \texttt{val} binding.

\subsubsection{Val Bindings}

\begin{grammar}
  <val-binding> ::= (\texttt{val} <name> <exp>)
\end{grammar}

Consider a \texttt{val} binding of the form:

\begin{verbatim}
(val x e)
\end{verbatim}

Let $\Gamma,\rho$ be $\Gamma_{g},\rho_{g}$ at the opening parenthesis of the binding.
Let $\Gamma_{c}$ be $\Gamma_{g}$ at the closing parenthesis of the binding.
\\\\
We assert that \texttt{x} be free in $\rho$ and bound in $\Gamma_{g}$.
Given $\Gamma_{c}[\texttt{x}]=\tau$, we assert that $\Gamma\vdash\texttt{e}=\tau$.
\\\\
Let $v$ be the result of evaluating $\texttt{e}$ in environment $\rho$.
We bind \texttt{x} to $v$ in $\rho_{g}$ at the closing parenthesis.
\\\\
Note that if \texttt{e} produces a side effect, it is produced \textbf{only} when \texttt{x} is referenced and \textbf{every} time \texttt{x} is referenced.
That is, references to \texttt{val}-bound names behave as zero-arity function calls rather than references to \texttt{let}-bound names.
The secret sauce here is that \texttt{val} bindings are simply macros.

\subsubsection{Function Definitions}

\begin{grammar}
  <function-definition> ::= (\texttt{define} <name> (\{ <name> \}) <exp>)
\end{grammar}

Consider a function definition of the form:

\begin{verbatim}
(define x (x1 ... xn) e)
\end{verbatim}


Let $\Gamma,\rho$ be $\Gamma_{g},\rho_{g}$ at the opening parenthesis of the binding.
\\\\
We assert that $\texttt{x}$ be bound in $\Gamma$ and free in $\rho$.
We assert that $\Gamma[\texttt{x}]=\texttt{(->}\ \texttt{(}\tau_{1}\ ...\ \tau_{n}\texttt{)}\ \tau_{r}\texttt{)}$.
We assert that $\Gamma[\texttt{x}1\mapsto\tau_{1},...,\texttt{x}n\mapsto\tau_{n}]\vdash\texttt{e}:\tau_{r}$.
\\\\
We bind \texttt{x}, in $\rho_{g}$ at the first character of the file, to the function value that, when applied to arguments $v_{1},...,v_{n}$, returns the result of evaluating \texttt{e} in the environment $\rho[\texttt{x}1\mapsto v_{1},...,\texttt{x}n\mapsto v_{n}]$.

\subsection{Use Declarations}

\begin{grammar}
  <use-declaration> ::= (\texttt{use} <symbol-literal>)
\end{grammar}

Use declarations are thinly-veiled preprocessor directives which are replaced by the contents of the file whose path 
is specified as a symbol literal. The path must be hard-coded relative to the location where the compiler is run.

\subsection{The Structure of Compost Programs}

\begin{grammar}
  <program> ::= \{ <def> \} <end-of-file>
\end{grammar}

Compost programs consist of a series of definitions.
All executable programs must contain a function \texttt{main} of type \texttt{(-> () unit)}, which serves as the entry point for the program.
\\\\
When a compiled Compost program is executed, \texttt{main} is invoked.
The program terminates when \texttt{main} has been fully evaluated.

\subsection{Initial Basis}

Compost includes an initial basis providing those functions not possible or practical to define in terms of the rest of the core Compost language.
A type annotation and description will be provided for each such function.
%A type annotation, description, and if possible, an implementaion, will be provided for each such function.

\subsubsection{Equality}

\begin{verbatim}
(: =i (-> (int int) bool))
\end{verbatim}

Integer equality.

\begin{verbatim}
(: =b (-> (bool bool) bool))
\end{verbatim}

Boolean equality.

\begin{verbatim}
(: =s (-> (sym sym) bool))
\end{verbatim}

Symbol equality.

\begin{verbatim}
(: =u (-> (unit unit) bool))
\end{verbatim}

Unit equality.
Always returns \texttt{true}.

\subsubsection{Arithmetic}

\begin{verbatim}
(: + (-> (int int) int))
\end{verbatim}

Two's complement addition.

\begin{verbatim}
(: - (-> (int int) int))
\end{verbatim}

Two's complement subtraction.

\begin{verbatim}
(: * (-> (int int) int))
\end{verbatim}

Two's complement multiplication.

\begin{verbatim}
(: / (-> (int int) int))
\end{verbatim}

Two's complement signed division.

\begin{verbatim}
(: % (-> (int int) int))
\end{verbatim}

Two's complement signed modulus.

\begin{verbatim}
(: udiv (-> (int int) int))
\end{verbatim}

Converts both of its arguments to 32-bit unsigned integers, performs 
unsigned division, and returns the result as a two's complement signed 
integer.

\begin{verbatim}
(: umod (-> (int int) int))
\end{verbatim}

Converts both of its arguments to 32-bit unsigned integers, performs 
unsigned modulus, and returns the result as a two's complement signed 
integer.

\begin{verbatim}
(: neg (-> (int) int))
\end{verbatim}

Two's complement negation.

\subsubsection{Integer Comparison}

\begin{verbatim}
(: > (-> (int int) bool))
\end{verbatim}

Returns \texttt{true} if the first argument is greater than the second.
Returns \texttt{false} otherwise.

\begin{verbatim}
(: < (-> (int int) bool))
\end{verbatim}

Returns \texttt{true} if the first argument is less than the second.
Returns \texttt{false} otherwise.

\begin{verbatim}
(: >= (-> (int int) bool))
\end{verbatim}

Returns \texttt{true} if the first argument is greater than or equal to the second.
Returns \texttt{false} otherwise.

\begin{verbatim}
(: <= (-> (int int) bool))
\end{verbatim}

Returns \texttt{true} if the first argument is less than or equal to the second.
Returns \texttt{false} otherwise.

\subsubsection{Boolean Logic}

\begin{verbatim}
(: not (-> (bool) bool))
\end{verbatim}

Logical NOT.

\begin{verbatim}
(: and (-> (bool bool) bool))
\end{verbatim}

Logical AND.

\begin{verbatim}
(: or (-> (bool bool) bool))
\end{verbatim}

Logical OR.

\begin{verbatim}
(: xor (-> (bool bool) bool))
\end{verbatim}

Logical XOR.

\subsubsection{Bitwise Operators}

\begin{verbatim}
(: & (-> (int int) int))
\end{verbatim}

Bitwise AND.

\begin{verbatim}
(: | (-> (int int) int))
\end{verbatim}

Bitwise OR.

\begin{verbatim}
(: ^ (-> (int int) int))
\end{verbatim}

Bitwise XOR.

\begin{verbatim}
(: << (-> (int int) int))
\end{verbatim}

Left bit shift first argument by second argument.

\begin{verbatim}
(: >> (-> (int int) int))
\end{verbatim}

Right bit shift first argument by second argument.

\begin{verbatim}
(: ~ (-> (int) int))
\end{verbatim}

Bitwise NOT, i.e. bitwise complement.

\subsubsection{I/O: Printing}

The following functions print representations of primitive values to stdout.

\begin{verbatim}
(: print-int (-> (int) unit))
\end{verbatim}

Prints the digits of the decimal representation of the absolute value of its argument in order from most to least significant, prefixed with a \texttt{-} if it is less than \texttt{0}.

\begin{verbatim}
(: print-bool (-> (bool) unit))
\end{verbatim}

Prints \texttt{true} to if its argument is the value \texttt{true} and prints \texttt{false} otherwise.

\begin{verbatim}
(: print-sym (-> (sym) unit))
\end{verbatim}

Prints its symbol argument's associated string.

\begin{verbatim}
(: print-unit (-> (unit) unit))
\end{verbatim}

Prints \texttt{unit}.

\begin{verbatim}
(: print-newline (-> () unit))
\end{verbatim}

Prints a single newline character.

\begin{verbatim}
(: print-ascii (-> (int) unit))
\end{verbatim}

Mods its argument by 256 and prints the ASCII character representation of the result.

\subsubsection{I/O: Input}

\begin{verbatim}
(: in (-> () int))
\end{verbatim}

Returns the integer representation of a single ASCII character read from stdin.

% COMMENTING THIS OUT BECAUSE NOT PROVIDING THIS TO USER
% \newpage

% \subsection{Lists and Helpers}

% \subsubsection{Integers}

% \begin{verbatim}
% (datatype list-int
%   ([cons-int (int list-int)]
%     [nil-int ()]))
% \end{verbatim}

% Lisp-style lists of integers.

% \begin{verbatim}
% (: filter-list-int (-> ((-> (int) bool) list-int) list-int))
% (define filter-list-int (f xxs)
%   (case xxs
%     ([(cons-int x xs)
%         (if (f x)
%           (cons-int x (filter-list-int f xs))
%           (filter-list-int f xs))]
%       [(nil-int) (nil-int)])))
% \end{verbatim}

% Returns a list containing all elements of \texttt{xxs} satisfying predicate \texttt{f}.

% \begin{verbatim}
% (: exists-list-int (-> ((-> (int) bool) list-int) bool))
% (define exists-list-int (f xxs)
%   (case xxs
%     ([(cons-int x xs)
%         (if (f x)
%           true
%           (exists-list-int f xs))]
%       [(nil-int) false])))
% \end{verbatim}

% Returns \texttt{true} if some element of \texttt{xxs} satisfies predicate \texttt{f}, \texttt{false} otherwise.

% \begin{verbatim}
% (: concat-list-int (-> (list-int list-int) list-int))
% (define concat-list-int (xxs ys)
%   (case xxs
%     ([(cons-int x xs) (cons-int x (concat-list-int xs ys))]
%       [(nil-int) ys])))
% \end{verbatim}

% Concatenates two lists of integers.

% \newpage

% \subsubsection{Symbols}

% \begin{verbatim}
% (datatype string
%   ([append (int string)]
%     [empty ()]))
% \end{verbatim}

% Lisp-style lists of symbols.

% \begin{verbatim}
% (: filter-string (-> ((-> (int) bool) string) string))
% (define filter-string (f xxs)
%   (case xxs
%     ([(append x xs)
%         (if (f x)
%           (append x (filter-string xs))
%           (filter-string f xs))]
%       [(empty) (empty)])))
% \end{verbatim}

% Returns a string containing all elements of \texttt{xxs} satisfying predicate \texttt{f}.

% \begin{verbatim}
% (: exists-string (-> ((-> (int) bool) string) bool))
% (define exists-string (f xxs)
%   (case xxs
%     ([(append x xs)
%         (if (f x)
%           true
%           (exists-string f xs))]
%       [(empty) false])))
% \end{verbatim}

% Returns \texttt{true} if some element of \texttt{xxs} satisfies predicate \texttt{f}, \texttt{false} otherwise.

% \begin{verbatim}
% (: concat-string (-> (string string) string))
% (define concat-string (xxs ys)
%   (case xxs
%     ([(append x xs) (append x (concat-string xs ys))]
%       [(empty) ys])))
% \end{verbatim}

% Concatenates two strings.

% \newpage

% \subsubsection{Booleans}

% \begin{verbatim}
% (datatype list-bool
%   ([cons-bool (bool list-bool)]
%     [nil-bool ()]))
% \end{verbatim}

% Lisp-style lists of booleans.

% \begin{verbatim}
% (: filter-list-bool (-> ((-> (bool) bool) list-bool) list-bool))
% (define filter-list-bool (f xxs)
%   (case xxs
%     ([(cons-bool x xs)
%         (if (f x)
%           (cons-bool x (filter-list-bool xs))
%           (filter-list-bool f xs))]
%       [(nil-bool) (nil-bool)])))
% \end{verbatim}

% Returns a list containing all elements of \texttt{xxs} satisfying predicate \texttt{f}.

% \begin{verbatim}
% (: exists-list-bool (-> ((-> (bool) bool) list-bool) bool))
% (define exists-list-bool (f xxs)
%   (case xxs
%     ([(cons-bool x xs)
%         (if (f x)
%           true
%           (exists-list-bool f xs))]
%       [(nil-bool) false])))
% \end{verbatim}

% Returns \texttt{true} if some element of \texttt{xxs} satisfies predicate \texttt{f}, \texttt{false} otherwise.

% \begin{verbatim}
% (: concat-list-bool (-> (list-bool list-bool) list-bool))
% (define concat-list-bool (xxs ys)
%   (case xxs
%     ([(cons-bool x xs) (cons-bool x (concat-list-bool xs ys))]
%       [(nil-bool) ys])))
% \end{verbatim}

% Concatenates two lists of booleans.

% PROJECT PLAN

\section{Project Plan} {
    Identify process used for planning, specification, and development
    \\\\
    Show your project timeline
    \\\\
    Identify roles/responsibilities/contributions of each team member
    \\\\
    Describe the software development environment used (tools and languages)
    \\\\
    If possible, include a visualization of version control commits (but not a dump of a commit log)
}

% ARCHITECTURAL DESIGN

\section{Architectural Design} {
    Give block diagram showing the major components of your compiler and the interfaces between them
    \\\\
    Summarize how the language's "interesting" features were implemented
    \\\\
    State who implemented each component
}

% TEST PLAN

\section{Test Plan} {
    Explain how your group approached unit and integration testing, and what automation was used.
    \\\\
    Show two or three representative source language programs along with the target language program 
    generated for each (if you can provide syntax highlighting and nice formatting that's REALLY useful)
    \\\\
    State who did what
}

% LESSONS LEARNED

\section{Lessons Learned} {
    Each team member should explain their most important takeaways from working on this project
    \\\\
    Include any advice the team has for future teams
}

\subsection{Roger Burtonpatel} {

}

\subsection{Randy Dang} {

}

\subsection{Jasper Geer} {

}

\subsection{Jackson Warhover} {

}

% APPENDIX 

\section{Appendix} {
    Attach a complete code listing of your translator with each module signed by its author(s)
    \\\\
    Do not include any automatically generated files, only the sources.
}

\end{document}
